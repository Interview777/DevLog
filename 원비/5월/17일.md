## ✏️ 오늘 한 일

- 홈 뷰에서 주간 달력 표시하는 기능 추가
    - calendarViewModel에 WeekMetadata를 만드는 메서드 구현
    - WeekMetadata를 토대로 주간 달력 데이터를 만드는 메서드 구현
    - 캘린더 뷰가 나타날 때와 사라질 때 뷰모델의 기준날짜를 선택된 날짜로 변경하는 로직 추가
    - 캘린더 뷰가 사라질 때 주간 달력용 배열daysForWeek의 데이터를 업데이트하고 이를 핸들러를 통해 뷰의 업데이트를 진행하는 로직 추가

## 🔥 해야 할일 Todo

- 리스트, 카테고리 타입의 테이블 뷰 구현하기
- 캘린더뷰 - custom modal view 구현

## 🤔 고민점

- 아이폰SE(3rd)에서 캘린더뷰 하단이 잘림
    - 일단, sheet의 크기는 medium으로 고정되어 있다. 애플이 그렇게 해놓음..
    - 따라서, 컴포지셔널 레이아웃을 만져서 달력의 크기를 조절해야 하는데.. 어떻게 함?
    - 또 다른 방법으로는 모달뷰를 새로 만들어버리는것..

- MVVM의 데이터 바인딩을 delegate로 구현하다보니..
    - delegate를 통한 데이터 바인딩 방식은 뷰모델 하나에 뷰컨트롤러 하나만 delegate로 지정할 수 있기 때문에, 하나의 뷰모델을 여러개의 뷰컨트롤러가 가지는 경우, 구현이 매우 어려워지는 단점이 있다.
    - 다시 말해, 이는 하나의 뷰모델은 하나의 뷰컨트롤러만 delegate를 통해 연결할 수 있는 것이고 우리는 이 방식이 MVP패턴과 다를게 무엇인가 라는 결론에 도달했다.
- 해결법 1: 여러개의 delegate만들기
    - 각 뷰에 해당하는 delegate객체를 여러개 만들면 되지만, 코드를 읽기가 매우매우 힘들어져서 좋은 방법은 아닌거 같다..
- 해결법 2: callback활용하기
    - 또 다른 해결법은 callback을 활용해 각 뷰컨트롤러간 사용할 함수를 선언하는 방식이 있다. 하지만 이 방법은 Rx를 사용하지 않았을 때 생기는 가독성이 매우 떨어지는 문제를 해결할 수 없다.
- 결론
    - 결론적으로, 기존 delegate나 callback을 통한 데이터 바인딩 방식이 로직이 복잡해짐에 따라 코드의 가독성이 매우 떨어진다는 결론이 나왔다.
    - 따라서, 홈 뷰를 그리는 동안 Rx를 적용해 데이터 바인딩을 하도록 리팩토링 도전해보고자 한다.
    - Rx를 적용하기 위한 러닝커브만 극복한다면, 코드의 가독성을 획기적으로 올릴 수 있고, 뷰와 뷰모델이 더 독립적으로 나뉘어 질 것이라 예상하고 있다.
